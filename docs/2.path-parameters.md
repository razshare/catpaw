> [!NOTE]
> _Attributes used in this document_
> - `#[Param]` - _supported by the open api service_ âœ…


# Path parameters

You can specify variable parts in your route paths.\
Those variable parts can then be passed to your route handler function as parameters.

```php
use function CatPaw\anyError;
use CatPaw\Unsafe;
use CatPaw\Web\Server;

function main(): Unsafe {
    return anyError(
        $server = Server::create(),
        $server->value->router->get(
            path: '/about/{name}',
            callback: static function(string $name) {
                return  "This is $name's about page.";
            }
        ),
        $server->value->start()->await(),
    );
}
```

The route path `/about/{username}` is referred to as a `symbolic path` because it contains the variable part `{username}`.

Each variable part in a symbolic path can be mapped to a route handler parameter, rendering the parameter a `path parameter`.\
So in the example above `string $username` is a path parameter.

## Types

Since they're just regular php parameters, path parameters can specify a primitive type.

The server will enforce this type matching, meaning all incoming requests to the given route _must_ comply with the types of the path parameters.

The server will respond with `400 Bad Request` when an incoming request doesn't comply with a path parameter's type.


Given this definition
```php
use function CatPaw\anyError;
use CatPaw\Unsafe;
use CatPaw\Web\Server;

function main(): Unsafe {
    return anyError(
        $server = Server::create(),
        $server->value->router->post(
            path: '/set/age/{age}',
            callback: static function(int $age) {
                return "This cat is now $age years old.";
            }
        ),
        $server->value->start()->await(),
    );
}
```

Sending `POST /set/age/yes` will result into a `400 Bad Request` answer from the server.

> [!NOTE]
> An appropriate request would be `POST /set/age/3`.


## More customization

Sometimes you need more than php primitives to enforce your path parameters' values.

Use `CatPaw\Web\Attributes\Param` to modify the matching pattern for your path parameters.

```php
use CatPaw\Web\Attributes\Param;
use function CatPaw\anyError;
use CatPaw\Unsafe;
use CatPaw\Web\Server;

function main(): Unsafe {
    return anyError(
        $server = Server::create(),
        $server->value->router->get(
            path: '/about/{name}',
            callback: static function(#[Param('\w{3,15}')] string $name) {
                return  "This is $name's about page.";
            }
        ),
        $server->value->start()->await(),
    );
}
```

The above path parameter will match strings that are at least 3 characters and at most 15 characters long.

## More on variable parts

As you would expect, a symbolic path can contain multiple variable parts

```php
use function CatPaw\anyError;
use CatPaw\Unsafe;
use CatPaw\Web\Server;

function main(): Unsafe {
    return anyError(
        $server = Server::create(),
        $server->value->router->get(
            path: '/about/{name}/child/{childName}',
            callback: static function(string $name, string $childName) {
                return  "This is $childName's about page, who is $name's kitten.";
            }
        ),
        $server->value->start()->await(),
    );
}
```

But variable parts are more powerful than that because they are not bound to any common web path rules.

Variable parts can be defined **anywhere** within the symbolic path, even as a partial part of a sub-path.

```php
'/about/{name}/child-{childName}'
```

That is a valid symbolic path and `string $childName` would still be a valid path parameter.

As a matter of fact we don't need the inner slashes (`/`) at all, the following is also valid

```php
'/parent:{name},child:{childName}'
```
> [!NOTE]
> The first forward slash is always required.
