# Entry point

Sometimes your application may need to execute some tasks before starting the server.<br />
While it is true that you can define those tasks the `main` function, the engine also provides a more object oriented way of executing code at startup.

Define a new class and a method, then mark your class with ```#[ApplicationScoped]``` and your method with ```#[Entry]```, like so:

```php
<?php

namespace Examples\ApplicationScoped;

use CatPaw\Attributes\ApplicationScoped;
use Psr\Log\LoggerInterface;
use Monolog\Logger;

#[ApplicationScoped]
class Starter {
	#[Entry]
	public function main(LoggerInterface $logger) {
		$logger->info("hello world!");
	}
}
```

The ```#[ApplicationScoped]``` attribute pulls the class into the main scope of your application, which means that this class can now benefit from dependency injections.<br />
The ```#[Entry]``` attribute marks the method as the entry point of your class, similar to a constructor.
<br/>

## Why not just use __construct?
Unlike ```__construct```, the ```#[Entry]``` marked method has the ability to ```yield``` and become a ```Generator``` or return a ```Promise```.<br />

```php
<?php

namespace Examples\ApplicationScoped;

use Amp\LazyPromise;
use Amp\Promise;
use CatPaw\Attributes\ApplicationScoped;
use CatPaw\Attributes\Entry;
use Generator;
use Psr\Log\LoggerInterface;

#[ApplicationScoped]
class Starter {
	public function promise(): Promise {
		return new LazyPromise(function() {
			return "I'm a promise!";
		});
	}

	#[Entry]
	public function main(LoggerInterface $logger): Generator {
		$logger->info(yield $this->promise());
	}
}
```

