# Modules

Any composer project can autoload different classes for you whenever your scripts <u>actually try to use</u> those classes.


In php, instead of defining a whole class, it is also possible to define functions within files, however composer will not be able to resolve those functions for you, because unlike classes, functions do not have an [__autoload](https://www.php.net/manual/en/function.autoload.php) or [spl_autoload_register](https://www.php.net/manual/en/function.spl-autoload-register.php) implementation.


But that doesn't mean we can't automatically require functions into our projects.

This feature will read your ```autoload.psr-4``` entry in your ```composer.json``` file and find all files ending with ```.module.php``` and simply require them once.

This is a hard ```require_once```, so there is no autoloading involved.

That being said, hard ```require``` should not be an issues for these types of cli projects, because they are meant to run indefenitely, which means sooner or later your files are going to be loaded in memory anyway if you were to use plain class methods.

Here's an example of using a function imported from a module:

```php
<?php
//this is located in src/lib/test.module.php
namespace Examples\Modules;

function test():string{
    return "this is a test module.";
}
```
```php
<?php

namespace {
    use CatPaw\Web\Utilities\Route;
    use CatPaw\Web\Attributes\StartWebServer;
    use function Examples\Modules\test;

    #[StartWebServer]

    function main() {
        Route::get("/modules",function(){
            return test();
        });
    }
}
```

Visiting [http://127.0.0.1:8080/modules](http://127.0.0.1:8080/modules) will show
```text
this is a test module.
```

There is a catch, though.

You may be loading old files that you are no longer using within in your project.